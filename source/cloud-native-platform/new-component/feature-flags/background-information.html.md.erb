---
title: Background information
last_reviewed_on: 2025-06-25
review_in: 6 months
weight: 98
---

# <%= current_page.data.title %>

## What is a feature flag?

The term "flag" dates back to the early days of computer architecture, in particular CPU registers.  Various registers have "flag bits" to control certain behaviour (e.g. the Z or zero-flag).  So "feature flags" are, quite literally, flags that control features; in other words, binary (Boolean) values that toggle certain features on or off when used as the condition in an `if` statement.  These days they have been expanded from just Booleans to cover any relatively small, finite set of values of any type, including strings, arrays and full JSON objects, although the precise range of types and values depends on the [feature-flag platform](#what-is-a-feature-flag-platform) in use.


## What is a feature-flag platform?

A feature-flag platform is a piece of software that allows you to manage the feature flags in your code.  It provides a user interface for creating, updating and deleting flags, as well as applying *targeting rules* governing which value (of the small, finite set) should be served when the flag is evaluated at runtime and monitoring those values served.  Feature-flag platforms usually provide SDKs for various programming languages, making it easy to integrate feature flags into your application code.

Through the SDKs, updates to feature-flag values take effect immediately, without requiring a redeployment of the application code.  Therefore a feature-flag platform enables real-time changes to live applications from a single centralised dashboard, which is much more convenient than having to create an admin dashboard (and corresponding logic in the code) for each application individually.  Examples of feature-flag platforms include [LaunchDarkly](https://launchdarkly.com/) and [Azure App Configuration](https://learn.microsoft.com/en-us/azure/azure-app-configuration/overview).  Tools such as [FluxCD](https://fluxcd.io/) and [ArgoCD](https://argo-cd.readthedocs.io/en/stable/) can also be used to manage environment variables that function as feature flags in a Kubernetes environment, although they are not feature-flag platforms as described here.


## Common uses of feature flags

The table below lists some of the more common uses of feature flags:

| Use case | Description |
|----------|-------------|
| **[Dark deployments](#dark-deployments)** | Separate deployments from releases by continually deploying code changes to Production while the feature is under development by hiding it from view behind a feature flag.  When the feature is judged to be ready for release, remove the feature flag; all users will then see the entire feature at the same time.
| **[Gradual roll-outs](#gradual-roll-outs)** | Safeguard releases by exposing a new feature to a select group of users initially by placing it behind a conditional feature flag that controls who can see it.  When the select group have verified that the feature works well, gradually include more users until it is available to everyone, at which point the feature flag can be removed.
| **[Feature experimentation](#feature-experimentation-beta-testing)** (AKA **Beta testing**)| Test emerging new features or changes in a controlled manner by enabling them for a subset of users.  This is the same process as **gradual roll-outs**, only this time the aim is to guide the development of a feature rather than to assure its safe release after it has been fully developed.  A reasonable outcome would be that the feature is withdrawn. |
| **[A/B testing](#a-b-testing)** | Compare the relative effectiveness of two (or more) variations of a completed feature by showing different variations to different subsets of users, often without their knowledge.  The targeting rules and defined set of values for the feature flag determine which users see which variation of the feature.  This can happen in test and production environments (where the feature has already been released).  The feature flags will be removed once the optimal version of the feature has been established. |
| **[User segmentation](#user-segmentation)** (AKA **Feature toggling**) | Target specific user segments with different features or configurations.  This is the same process as **A/B testing**, only here the aim is to provide a customised experience for different users according to their preferences.  The feature flags are usually permanent. |
| **[User permissions](#user-permissions)** | Control access to certain features based on user roles or permissions.  This is the same process as **user segmentation**, only here the differences in user experience are based on privileges rather than preferences. |
| **[Operational toggles](#operational-toggles)** (AKA **Kill switches**) | Control operational aspects of the application, such as enabling or disabling certain features based on system load or the emergence of bugs to ensure stability and availability.  The feature flags are usually permanent. |
| **[Monitoring and logging](#monitoring-and-logging)** | Activate or deactivate performance monitoring, increase or decrease error logging etc. in response to current conditions; e.g. the emergence of a bug.  The feature flags are usually permanent. |
| **[Live debugging](#live-debugging)** | Enable or disable debugging features in Production to trouble-shoot bugs that cannot be reproduced in lower environments.  The feature flags are usually permanent. |
| **[Short-cuts in testing](#short-cuts-in-testing)** | Enable or disable certain features in test environments to speed up testing; e.g., removing authentication and other validation steps.  The feature flags are usually permanent. |
| **[Feature deprecation](#feature-deprecation)** | Gradually phase out old features by disabling them for selected users while still keeping the code in place.  This is the inverse process of **gradual roll-outs**. The feature flag will be removed when the feature has been removed from the last set of users. |


## Recommendations for using feature flags

Each of the uses listed above comes with its own set of recommendations, as described below.


### Dark deployments

#### Pros

Dark deployments help facilitate CI/CD and [trunk-based development](/cloud-native-platform/new-component/feature-flags/trunk-based-development.html), which are key practices of high-performing software teams.  Teams that would ordinarily practise feature-based development can merge their code frequently, thereby reducing the impact of merge conflicts and helping to keep the main branch stable and deployable.

![Trunk based development with feature flags](/images/TBD_FeatureFlag.png)

Summary of the end-to-end process for trunk-based development with feature flags:

1. Developer creates and commits a short-lived feature branch with the feature flag ON in lower environments yet OFF in Production.
2. Feature is implemented and code merged iteratively in short development cycles.
3. Changes are continuously released with the feature flag ON in lower environments yet OFF in Production.
4. The feature flag is turned ON in Production; then, once the feature is verified to be working correctly, the feature flag is removed altogether.

#### Cons

Separating deployments from releases is not always a good thing!  The [Agile Manifesto](https://agilemanifesto.org/principles.html) emphasises the importance of *working software* rather than frequent deployments.  A new piece of functionality hidden behind a feature flag cannot be considered to be "working".

The essence of Agile is to deliver *new* working software to users frequently, so that they can provide feedback and the team can make adjustments as necessary to cater for changing or misunderstood requirements.  Dark deployments hide the work from users until it is fully complete; hence any problems with the feature in real-world use will go undetected until very late in the day, where they could have a much more serious impact than if they had been found earlier on.

Dark deployments also allow "work-in-progress" code to be merged into `master`, even when it is clearly unfinished or doesn't work properly, because it can be hidden behind a feature flag.  Whilst this may be help to avoid merge conflicts, it discourages the essential practice of breaking features down into their smallest *releasable* components, which is in line with Agile principles and the primary benefit of trunk-based development.  WIP code is also more likely to change or be removed, which could be problematic if another developer has started to rely on it in its current form.  Finally, comprehensive automated testing is more complicated as all combinations of feature-flag values need to be included, which is easily overlooked while a feature is still under construction.

#### Recommendation

Practising trunk-based development and minimising merge conflicts can be achieved in two ways:

1. by breaking features down into their smallest releasable components and continuously merging (without feature flags); or
2. by hiding WIP features behind feature flags (and continuously merging).

**Breaking features down into their smallest releasable components is *always* the best approach**; but it's difficult and time-consuming and hence teams are disinclined to do it, particularly when they have an easier alternative courtesy of dark deployments.  Therefore:

- **Dark deployments should only be done when there is a *business reason* for doing so**; it should not be done as an alternative to breaking features down into their smallest releasable components.

An example of a business reason might be that releases must happen according to a regular and preset schedule (e.g., once a quarter) rather than being allowed to take place continuously.  In an ideal world, this wouldn't be the case because it restricts the opportunities to receive valuable user feedback; but sometimes the users themselves are not ready for releases outside certain times.

In such circumstances, a golden rule should be:

- **Do not use dark deployments to release WIP code to Production unless it is fully working**; it can be functionally incomplete but those elements that have been implemented must be fully verified through testing in lower environments.

Finally:
    
- **Feature flags should *always* be set to *enable* the new feature in lower environments.**  This will help ensure that the feature is tested sufficiently during development.
- **Changes to feature flags that influence the user experience in a live environment must be approved by the business owners beforehand**; where possible, this approval must be recorded by the feature-flag platform and be visible when required.
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.


### Gradual roll-outs

#### Pros

Gradual roll-outs support safer releases when the team are releasing large, complex features all at once where there is a significant chance that something might not work for one or more sets of users.

#### Cons

Gradual roll-outs may encourage teams to release features in full before they are ready rather than releasing a steady stream of small, beneficial changes that are easy to test and roll back if necessary.  It also shifts the emphasis of user testing to a live environment where it may be better to focus more on testing in a lower environment to ensure that the feature is fit for purpose when it is released in Production.  Finally, there is a danger that the user segments chosen to test the feature early may not be representative of the wider user base, leading to a false sense of security that the feature is working well when it may not be.

#### Recommendation

As stated above, **breaking features down into their smallest releasable components is always the best option**.  Therefore:

- **Gradual roll-outs should only be done when some of the *users* are not ready for the new feature.**  In other words, gradual roll-outs should protect against incomplete or uncertain *business processes* rather than features that may contain bugs.

In some circumstances, it may be very difficult to break a large feature down into small, releasable units that add value; under these conditions, the business owners may feel more comfortable with a gradual roll-out.  If so, a golden rule should be:

- **Do not use raw IDs in the feature-flag platform for the purpose of segmenting users** as they could easily be mistyped and cannot be verified in the code.  Instead, use a descriptive name for the user segment that is easy to understand and verify in the code; in other words, the code should ultimately control the logic of who sees the feature, not the feature-flag platform.

Finally:
    
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.
- **Changes to feature flags that influence the user experience in a live environment must be approved by the business owners beforehand**; where possible, this approval must be recorded by the feature-flag platform and be visible when required.


### Feature experimentation / Beta testing

#### Pros

Beta testing can assist the development of a feature and provide timely feedback from users as to which aspects of the feature will actually prove to be useful in the real world.

#### Cons

As with gradual roll-outs, there is a danger that the users volunteering to test the feature may not be representative of overall user community, with selection bias likely to be significant.

#### Recommendation

**The use of feature flags to accomplish beta testing is acceptable** as there are few convenient alternatives.  As with gradual roll-outs, the features should always be working (albeit incomplete) before they are released to users, raw IDs should not be used in the feature-flag platform, feature flags should be removed once testing has been concluded, and business approval must be gained beforehand.


### A/B testing

#### Pros

This is a tried and tested method of improving an application by comparing the relative effectiveness of two (or more) variations of a completed feature and then retaining the best one.

#### Cons

None.  (There should be little danger of selection bias or lack of representation since the users are generally unaware that they are part of an A/B test and hence will not be biased towards one variation or the other, and they can be chosen at random.)

#### Recommendation

**The use of feature flags to accomplish A/B testing is acceptable.**  As with gradual roll-outs, the features should always be working before they are released to users, raw IDs should not be used in the feature-flag platform, feature flags should be removed once testing has been concluded, and business approval must be gained beforehand.


### User segmentation

#### Pros

A standard feature of many applications, this is the act of providing a customised experience for different users (or groups of users) according to their needs or preferences.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags**; although it may provide a convenient short-cut to achieving customisation, it is not the right tool for the job.  Instead, the code should be written to recognise the differences between groups of users and provide the appropriate experience for each user through polymorphism, inheritance and so on.  Preferences for individual users should be stored in configuration files or an application database.  Using a feature-flag platform for this purpose complicates the architecture and increases the cost unnecessarily: it creates a dependency on the feature-flag platform that is wholly unnecessary and lowers the capability of the code itself.


### User permissions

#### Pros

An essential feature of nearly all applications, this is the process of providing a regulated experience for different groups of users according to their privileges.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags**; there are many better alternatives for implementing roles and permissions within an application, such as using a common IdAM component created specifically for this purpose.


### Operational toggles

#### Pros

The use of toggles to change the behaviour of certain features (or even disable them altogether) at runtime can help application administrators to prevent or limit the impact of high or unstable loads, unexpected responses from dependent services, lack of availability of essential resources and other unusual conditions or occurrences.

#### Cons

None.

#### Recommendation

**The use of feature flags to control or optimise the operation of the application during difficult periods is encouraged.**  However, a formal procedure for deciding when such changes are necessary, who should do them and how they should be recorded must be in place and reviewed on a regular basis.  Business approval must be gained before any changes are made.


### Monitoring and logging

#### Pros

The use of feature flags to dynamically alter the level of diagnostic information emitted by an application can help administrators to gain extra insights regarding the performance of the application when necessary (e.g., to explain unexpected behaviour).

#### Cons

None.

#### Recommendation

**The use of feature flags to increase or decrease diagnostic information according to need is encouraged.**  This both provides a means of capturing extra information when it is needed and reducing unnecessary log capture and storage during normal operation.  Care should be taken to ensure there is no adverse effect on application performance.


### Live debugging

#### Pros

In addition to capturing more diagnostic information, feature flags can be used to control the behaviour of the application in order to troubleshoot bugs in Production that cannot be reproduced in lower environments.  For example, a particular user process exhibiting a bug could be dynamically modified to alter or even miss certain steps in order to isolate the problem and identify the cause.

#### Cons

Making experimental changes to a live application is always dangerous due to the possibility of causing other problems for logged-in customers from unintended side-effects of the developers' actions.  Furthermore, these have the potential to distort the regular usage metrics relied upon by business teams monitoring the performance and effectiveness of the application.

#### Recommendation

**The use of feature flags to enable live debugging is acceptable *only as a last resort*, and great care must be taken.**  The developers carrying out the live debugging should be the most senior developers available in order to minimise the possibility of mistakes.  Approval *by the service owner* must be gained before any changes are made.


### Short-cuts in testing

#### Pros

Feature flags can be used in a test environment to speed up the testing process; for example, by-passing the need to authenticate through the use of a special privileged user account, or assigning stock data and properties to a test user.

#### Cons

There is a danger that these short-cuts will be forgotten and left in place, and potentially exploited.  It is also more difficult to record exactly what testing took place when the tests are influenced by feature flags controlled in a separate piece of software.

#### Recommendation

**Feature flags should *not* be used for taking short-cuts in testing.**  Instead of simplifying an integration test (for example, by removing the need to authenticate), it is better to create smaller service- or contract-level tests lower down the [test pyramid](/standards/principles/test.html#types-of-testing) that verify the individual components of the code in isolation and have fewer but nonetheless complete integration tests for the end-to-end user journey.  Traditional methods of creating test data are always available and are likely to be better suited to the task (e.g., creating entities in a test database rather than injecting them from the feature-flag platform).


### Feature deprecation

#### Pros

Feature flags can be used to enable the gradual removal (or "gradual roll-in") of features on a per-user (or per-group) basis, to ensure that all users are prepared for the withdrawal of the feature in question.

#### Cons

None.

#### Recommendation

**The use of feature flags for gradual feature deprecation is acceptable.**  As with gradual roll-outs, raw IDs should not be used in the feature-flag platform, feature flags should be removed once the feature has been removed for all users, and business approval must be gained beforehand.


## Managing feature flags at HMCTS

The following mechanisms for managing feature flags are currently used by HMCTS product teams:

### [LaunchDarkly](https://launchdarkly.com/)

A commercial feature-flag platform that provides a web dashboard for maintaining and editing feature flags, seeing their recent evaluations and an audit trail of past changes made, along special features for experimentation, use of AI etc. as well as SDKs for various programming languages.  It is currently the feature-flag platform of choice for HMCTS projects.

### [Azure App Configuration](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)

A Microsoft Azure service that provides a centralised configuration store for applications, including feature flags.

### Environment variables

A simple way to manage feature flags by storing them as environment variables in the application's runtime environment.


## Recommendations for managing feature flags

Assuming that the advice above has been followed regarding the use of feature flags, the following recommendations apply to the choice of tool for managing them:

### Azure App Configuration

#### Pros

For teams already familiar with the Azure dashboard, the interface will be familiar and logical.  For applications that use Azure services, particularly Microsoft Entra ID (Azure AD), it will likely be fairly easy to introduce feature flags to the application.  For simple binary (on/off) feature toggles, Azure App Configuration provides some nice features such as targeting and time-window filters that could be very handy for A/B testing in particular and likely one or two others.

#### Cons

Azure App Configuration is primarily aimed at Boolean flags, and it seems that initially those were the only supported type of feature flag.  It is now possible, using "variant feature flags", to return other types of vaue (e.g., strings, arrays and JSON objects); but these are defined and managed separately and the overall interface feels more awkward than the UI for LaunchDarkly.  For teams less familiar with the Azure dashboard, the learning curve may be steep, particularly if they are not already using Azure services.

The targeting rules appear less flexible than those provided by LaunchDarkly, focusing instead on randomising the user experience rather than targeting a specific set of users; this can be done but only through the use of Azure AD identities and groups, which may not be available in all applications.  It is not in widespread use at HMCTS and may not actually be used by any active product teams; as such, its facilities for feature-flag approvals, audit log of changes etc. are largely unknown.  (They are likely to exist somewhere; but they may be part of another Azure service rather than obviously connected to the feature flags themselves, which would be less convenient.)

Finally, it's not clear whether Azure App Configuration provides a single centralised view of all feature flags in use in Azure across all applications.  Teams used to working with Azure may prefer to create a separate instance of Azure App Configuration for each application.  This not only results in the loss of the centralised view but could also end up being more expensive than using LaunchDarkly, which is currently charged per user rather than per instance.

#### Recommendation

Azure App Configuration is recommended for new applications based on Azure services, in particular **MS Entra ID (Azure AD)**, that are to be managed by teams already familiar with the Azure dashboard and who have a reasonable degree of competence with Azure services in general.


### Environment variables

#### Pros

All product teams should be familiar with using environment variables in code; hence there should be little or no extra learning required.  Environment variables are also infinitely customisable (with reason), so whatever use of feature flags the team should have can be accommodated.  They are also free!

#### Cons

Environment variables are not a feature-flag platform; therefore the primary benefits of a feature-flag platform are not available, namely centralised management of feature flags across all applications via a dashboard, an audit trail of changes made, approvals and so on.  All of the targeting rules, handling of separate variations etc. has to be done in the code itself, which could rapidly lead to unnecessarily complexity and (subsequently) mounting tech debt.

Furthermore, applications have to be set up in a way that enables the environment variables to be changed dynamically at runtime, which is non-trivial.  For example, a containerised application that is triggered to restart when an environment variable has been changed, where the restart only occurs once all current user transactions (that started with the old value in place) have been completed.  (`ccd-data-store-api` is an example of an application that does this.)  Choosing this deployment set-up for an application may not always be desirable or convenient for other reasons.

#### Recommendation

Environment variables will suffice when the actual uses of feature flags are relatively simple and don't require separate approval or logging; e.g. displaying or updating a service message during an outage. 

### LaunchDarkly

#### Pros

A full-featured feature-flag platform that provides every facility we need (and several more that we don't!).  It is comprehensive, powerful and easy to use, with a wealth of supporting materials in the form of SDKs, documentation and blog posts.

#### Cons

It is expensive.

#### Recommendation

LaunchDarkly is the tool of choice for all projects that would not be a good fit for Azure App Configuration and require more sophisticated use of feature flags than environment variables can provide.  However, just because you *can* use LaunchDarkly does not mean you *should*!  The most important decision to make is whether to use a feature flag **at all**; which feature-flag platform to use is secondary.
