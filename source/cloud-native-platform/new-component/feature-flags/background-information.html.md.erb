---
title: Background information
last_reviewed_on: 2025-06-25
review_in: 6 months
weight: 98
---

# <%= current_page.data.title %>

## What is a feature flag?

The term "flag" dates back to the early days of computer architecture, in particular CPU registers.  Various registers have "flag bits" to control certain behaviour (e.g. the Z or zero-flag).  So "feature flags" are, quite literally, flags that control features; in other words, binary (Boolean) values that toggle certain features on or off when used as the condition in an `if` statement.  These days they have been expanded from just Booleans to cover any relatively small, finite set of values of any type, including strings, arrays and full JSON objects, although the precise range of types and values depends on the [feature-flag platform](#what-is-a-feature-flag-platform) in use.

## What is a feature-flag platform?

A feature-flag platform is a piece of software that allows you to manage the feature flags in your code.  It provides a user interface for creating, updating and deleting flags, as well as applying *targeting rules* governing which value (of the small, finite set) should be served when the flag is evaluated at runtime and monitoring those values served.  Feature-flag platforms usually provide SDKs for various programming languages, making it easy to integrate feature flags into your application code.

Through the SDKs, updates to feature-flag values take effect immediately, without requiring a redeployment of the application code.  Therefore a feature-flag platform enables real-time changes to live applications from a single centralised dashboard, which is much more convenient than having to create an admin dashboard (and corresponding logic in the code) for each application individually.

## Common uses of feature flags

The table below lists some of the more common uses of feature flags:

| Use case | Description |
|----------|-------------|
| **Dark deployments** | Separate deployments from releases by continually deploying code changes to Production while the feature is under development by hiding it from view behind a feature flag.  When the feature is judged to be ready for release, remove the feature flag; all users will then see the entire feature at the same time.
| **Gradual roll-outs** | Safeguard releases by exposing a new feature to a select group of users initially by placing it behind a conditional feature flag that controls who can see it.  When the select group have verified that the feature works well, gradually include more users until it is available to everyone, at which point the feature flag can be removed.
| **Feature experimentation** (AKA **Beta testing**)| Test emerging new features or changes in a controlled manner by enabling them for a subset of users.  This is the same process as **gradual roll-outs**, only this time the aim is to guide the development of a feature rather than to assure its safe release after it has been fully developed.  A reasonable outcome would be that the feature is withdrawn. |
| **A/B testing** | Compare the relative effectiveness of two (or more) variations of a completed feature by showing different variations to different subsets of users, often without their knowledge.  The targeting rules and defined set of values for the feature flag determine which users see which variation of the feature.  This can happen in test and production environments (where the feature has already been released).  The feature flags will be removed once the optimal version of the feature has been established. |
| **User segmentation** (AKA **Feature toggling**) | Target specific user segments with different features or configurations.  This is the same process as **A/B testing**, only here the aim is to provide a customised experience for different users according to their preferences.  The feature flags are usually permanent. |
| **User permissions** | Control access to certain features based on user roles or permissions.  This is the same process as **user segmentation**, only here the differences in user experience are based on privileges rather than preferences. |
| **Operational toggles** (AKA **Kill switches**) | Control operational aspects of the application, such as enabling or disabling certain features based on system load or the emergence of bugs to ensure stability and availability.  The feature flags are usually permanent. |
| **Monitoring and logging** | Activate or deactivate performance monitoring, increase or decrease error logging etc. in response to current conditions; e.g. the emergence of a bug.  The feature flags are usually permanent. |
| **Live debugging** | Enable or disable debugging features in Production to trouble-shoot bugs that cannot be reproduced in lower environments.  The feature flags are usually permanent. |
| **Short-cuts in testing** | Enable or disable certain features in test environments to speed up testing; e.g., removing authentication and other validation steps.  The feature flags are usually permanent. |
| **Feature deprecation** | Gradually phase out old features by disabling them for selected users while still keeping the code in place.  This is the inverse process of **gradual roll-outs**. The feature flag will be removed when the feature has been removed from the last set of users. |


## Recommendations for using feature flags

Each of the uses listed above comes with its own set of recommendations, as described below.


### Dark deployments

#### Pros

Dark deployments help facilitate CI/CD and [trunk-based development](/cloud-native-platform/new-component/feature-flags/trunk-based-development.html), which are key practices of high-performing software teams.  Teams that would ordinarily practise feature-based development can merge their code frequently, thereby reducing the impact of merge conflicts and helping to keep the main branch stable and deployable.

![Trunk based development with feature flags](/images/TBD_FeatureFlag.png)

#### Cons

Dark deployments discourage teams from breaking features down into their smallest releasable components, because there is no longer a need to do so in order to merge code back into `master` (since the code will never be executed by a user).  They also discourage regular and comprehensive testing before code is deployed to production, because the feature flag allows teams to deploy incomplete or broken features without releasing them to end-users.  This effectively defers the work of comprehensive testing and user feedback until the service is fully released to all users; hence any problems with the feature in real-world use will go undetected until very late in the day, where they could have a much more serious impact than if they had been found before the feature was fully complete.

Furthermore, dark deployments allow team members to work in isolation for longer, where they don't know what others are working on; code hidden behind a feature flag may or may not make the final cut for a release and hence cannot be reused or relied upon.  This increases the likelihood of unintended duplication or redundancy between the work of two different developers who have done the same thing in two different ways.  Comprehensive automated testing is more complicated as all combinations of feature-flag values need to be included, which is easily overlooked while a feature is still under construction.

#### Recommendation

**Breaking features down into their smallest releasable components is *always* a good idea**; but it's hard and time-consuming and hence teams are disinclined to do it, particularly when they have an easier alternative courtesy of dark deployments.  Therefore:

- **Dark deployments should only be done by teams that are happy to practise trunk-based development**, whereby they will naturally break features down into small, releasable components and have a comprehensive and mature testing strategy in place before code reaches Production.

If you find them irresistible, then a golden rule should be:

- **Do not use dark deployments to hide features in Production that do not work**; instead, test fully in a lower environment before merging the (partially complete, fully working) code to `master`.

Finally:
    
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.


### Gradual roll-outs

#### Pros

Gradual roll-outs support safer releases when the team are releasing large, complex features all at once where there is a significant chance that something might not work for one or more sets of users.

#### Cons

Gradual roll-outs may encourage teams to release features in full before they are ready rather than releasing a steady stream of small, beneficial changes that are easy to test and roll back if necessary.  It also shifts the emphasis of user testing to Production where it may be better to focus more on testing in a lower environment to ensure that the feature is fit for purpose when it is released in Production.  Finally, there is a danger that the user segments chosen to test the feature early may not be representative of the wider user base, leading to a false sense of security that the feature is working well when it may not be.

#### Recommendation

As stated above, **breaking features down into their smallest releasable components is the best option**.  Therefore:

- **Gradual roll-outs should only be done when some of the *users* are not ready for the new feature.**  In other words, gradual roll-outs should protect against incomplete or uncertain *business processes* rather than features that may contain bugs.

In some circumstances, it may be very difficult to break a large feature down into small, releasable units that add value; under these conditions, the business owners may feel more comfortable with a gradual roll-out.  If so, a golden rule should be:

- **Do not use raw IDs in the feature-flag platform for the purpose of segmenting users** as they could easily be mistyped and cannot be verified in the code.  Instead, use a descriptive name for the user segment that is easy to understand and verify in the code; in other words, the code should ultimately control the logic of who sees the feature, not the feature-flag platform.

Finally:
    
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.


### Feature experimentation / Beta testing

#### Pros

Beta testing can assist the development of a feature and provide timely feedback from users as to which aspects of the feature will actually prove to be useful in the real world.

#### Cons

As with gradual roll-outs, there is a danger that the users volunteering to test the feature may not be representative of overall user community, with selection bias likely to be significant.

#### Recommendation

The use of feature flags to accomplish beta testing is acceptable as there are few convenient alternatives.  As with gradual roll-outs, the features should always be working (albeit incomplete) before they are released to users, raw IDs should not be used in the feature-flag platform, and the feature flags should be removed once testing has been concluded.


### A/B testing

#### Pros

This is a tried and tested method of improving an application by comparing the relative effectiveness of two (or more) variations of a completed feature and then retaining the best one.

#### Cons

None.  (There should be little danger of selection bias or lack of representation since the users are unaware that they are part of an A/B test and hence will not be biased towards one variation or the other, and they can be chosen at random.)

#### Recommendation

This use of feature flags is acceptable.  As with gradual roll-outs, the features should always be working before they are released to users, raw IDs should not be used in the feature-flag platform, and the feature flags should be removed once testing has been concluded.


### User segmentation

#### Pros

Provide a customised experience for different users according to their preferences.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags.**  Instead, the code should be written to recognise the differences between groups of users and provide the appropriate experience for each user through polymorphism, inheritance and so on.  Preferences for individual uses should be stored in configuration files or an application database.  Using a feature-flag platform for this purpose complicates the architecture and increases the cost unnecessarily.


### User permissions

#### Pros

Provide a regulated experience for different users according to their privileges.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags.**  It should be enforced through the usual mechanisms for implementing roles and permissions within an application.


### Operational toggles

#### Pros

Enables administrators to prevent or limit the impact of high or unstable loads, unexpected errors, lack of availability of essential resources and so on by disabling certain features or changing their behaviour.

#### Cons

None.

#### Recommendation

The use of feature flags to control or optimise the operation of the application during difficult periods is encouraged.  However, a formal procedure for deciding when such changes are necessary, who should do them and how they should be recorded must be in place and reviewed on a regular basis.


### Monitoring and logging

#### Pros

Enables administrators to increase diagnostic tools and gain extra insights regarding the performance of the application when necessary (e.g., to explain unexpected behaviour).

#### Cons

None.

#### Recommendation

This use of feature flags is acceptable.


### Live debugging

#### Pros

Gives developers some tools to troubleshoot bugs in Production that cannot be reproduced in lower environments.

#### Cons

Making experimental changes to a live application is always dangerous due to the possibility of causing other problems for customers from unintended side-effects of the developers' actions.  Furthermore, these have the potential to distort the regular usage metrics relied upon by business teams monitoring the performance and effectiveness of the application.

#### Recommendation

This practice is acceptable but great care must be taken.  The developers carrying out the live debugging should be the most senior developers available in order to minimise the possibility of mistakes.


### Short-cuts in testing

#### Pros

Enables faster testing through by-passing the usual application controls or assigning stock data and properties to a test user etc.

#### Cons

There is a danger that the short-cuts will be forgotten and left in place, and potentially exploited.  It is also more difficult to demonstrate what has been tested after the fact.

#### Recommendation

**This should *not* be done using feature flags.**  Traditional methods of creating test data are always available and are likely to be better suited to the task (e.g., creating entities in a test database rather than injecting them from the feature-flag platform).


### Feature deprecation

#### Pros


#### Cons


#### Recommendation

Feature deprecation is a great way to gradually phase out old features, but it can lead to confusion if the feature flag is not removed after the feature is no longer needed.  Therefore, it is important to have a process in place for retiring feature flags once they are no longer needed.  This can be done by regularly reviewing the list of feature flags and removing any that are no longer in use.


## Feature-flag platforms at HMCTS

The following feature-flag platforms are currently in use at HMCTS:

### [LaunchDarkly](https://launchdarkly.com/)

A commercial feature-flag platform that provides a user interface for managing feature flags, as well as SDKs for various programming languages.  It is the recommended feature-flag platform for HMCTS projects.

### [Azure App Configuration](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)

A Microsoft Azure service that provides a centralised configuration store for applications, including feature flags.  It is suitable for projects that are already using Azure services and want to keep their feature flags within the Azure ecosystem.

### Environment variables

A simple way to manage feature flags by storing them as environment variables in the application's runtime environment.  This is suitable for small projects or projects that do not require a full-featured feature-flag platform.


End to end Process:

1. Developer creates and commits short lived feature branch with Feature flag off.
2. Implements feature through iterations of small feature lifecycle.
3. Code is continuously released.
4. Retire feature toggle.


### Accessing LaunchDarkly

Developers automatically get access by being part of 'DTS CFT Developers' or 'DTS SDS Developers', non-developers can get access with the 'DTS LaunchDarkly' group.
see [onboarding](../onboarding/person/index.html) process to request access. You will need to login from [myapps.microsoft.com](https://myapps.microsoft.com/hmcts.net).

After you've logged in once you will be able to login from [app.launchdarkly.com](https://app.launchdarkly.com/).

### Documentation

Documentation can be accessed directly from the [LaunchDarkly](https://docs.launchdarkly.com/home) website.
Their [blog](https://launchdarkly.com/blog/) contains good information.

### Creating a new project

See [hmcts/launchdarkly-terraform](https://github.com/hmcts/launchdarkly-terraform) for instructions on how to setup your new project.

### Environments

We currently provide 'Test' and 'Production' environments by default within Launch Darkly. Flags are generally set to the same value in both 'Production' and the 'Test' environment, [flag targeting](https://docs.launchdarkly.com/guides/tutorials/rules-and-targeting) is used to control rollout of flags to users across environments.

If your team does require additional environments, you can do this by updating your teams [terraform.tfvars](https://github.com/hmcts/launchdarkly-terraform/blob/896019ed1efdebdf9237b7811ab2b9585a7708f2/terraform.tfvars#L59-L61). 
It is not recommended to do this as targeting rules should be simpler to manage and ensure consistency across environments.

