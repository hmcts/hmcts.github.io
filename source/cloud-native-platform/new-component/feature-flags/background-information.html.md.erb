---
title: Background information
last_reviewed_on: 2025-06-25
review_in: 6 months
weight: 98
---

# <%= current_page.data.title %>

## What is a feature flag?

The term "flag" dates back to the early days of computer architecture, in particular CPU registers.  Various registers have "flag bits" to control certain behaviour (e.g. the Z or zero-flag).  So "feature flags" are, quite literally, flags that control features; in other words, binary (Boolean) values that toggle certain features on or off when used as the condition in an `if` statement.  These days they have been expanded from just Booleans to cover any relatively small, finite set of values of any type, including strings, arrays and full JSON objects, although the precise range of types and values depends on the [feature-flag platform](#what-is-a-feature-flag-platform) in use.

## What is a feature-flag platform?

A feature-flag platform is a piece of software that allows you to manage the feature flags in your code.  It provides a user interface for creating, updating and deleting flags, as well as applying *targeting rules* governing which value (of the small, finite set) should be served when the flag is evaluated at runtime and monitoring those values served.  Feature-flag platforms usually provide SDKs for various programming languages, making it easy to integrate feature flags into your application code.

Through the SDKs, updates to feature-flag values take effect immediately, without requiring a redeployment of the application code.  Therefore a feature-flag platform enables real-time changes to live applications from a single centralised dashboard, which is much more convenient than having to create an admin dashboard (and corresponding logic in the code) for each application individually.

## Common uses of feature flags

The table below lists some of the more common uses of feature flags:

| Use case | Description |
|----------|-------------|
| **[Dark deployments](#dark-deployments)** | Separate deployments from releases by continually deploying code changes to Production while the feature is under development by hiding it from view behind a feature flag.  When the feature is judged to be ready for release, remove the feature flag; all users will then see the entire feature at the same time.
| **[Gradual roll-outs](#gradual-roll-outs)** | Safeguard releases by exposing a new feature to a select group of users initially by placing it behind a conditional feature flag that controls who can see it.  When the select group have verified that the feature works well, gradually include more users until it is available to everyone, at which point the feature flag can be removed.
| **[Feature experimentation** (AKA **Beta testing**)](#feature-experimentation-beta-testing)| Test emerging new features or changes in a controlled manner by enabling them for a subset of users.  This is the same process as **gradual roll-outs**, only this time the aim is to guide the development of a feature rather than to assure its safe release after it has been fully developed.  A reasonable outcome would be that the feature is withdrawn. |
| **[A/B testing](#a-b-testing)** | Compare the relative effectiveness of two (or more) variations of a completed feature by showing different variations to different subsets of users, often without their knowledge.  The targeting rules and defined set of values for the feature flag determine which users see which variation of the feature.  This can happen in test and production environments (where the feature has already been released).  The feature flags will be removed once the optimal version of the feature has been established. |
| **[User segmentation (AKA **Feature toggling**)](#user-segmentation)** | Target specific user segments with different features or configurations.  This is the same process as **A/B testing**, only here the aim is to provide a customised experience for different users according to their preferences.  The feature flags are usually permanent. |
| **[User permissions](#user-permissions)** | Control access to certain features based on user roles or permissions.  This is the same process as **user segmentation**, only here the differences in user experience are based on privileges rather than preferences. |
| **[Operational toggles](#operational-toggles)** (AKA **Kill switches**) | Control operational aspects of the application, such as enabling or disabling certain features based on system load or the emergence of bugs to ensure stability and availability.  The feature flags are usually permanent. |
| **[Monitoring and logging](#monitoring-and-logging)** | Activate or deactivate performance monitoring, increase or decrease error logging etc. in response to current conditions; e.g. the emergence of a bug.  The feature flags are usually permanent. |
| **[Live debugging](#live-debugging)** | Enable or disable debugging features in Production to trouble-shoot bugs that cannot be reproduced in lower environments.  The feature flags are usually permanent. |
| **[Short-cuts in testing](#short-cuts-in-testing)** | Enable or disable certain features in test environments to speed up testing; e.g., removing authentication and other validation steps.  The feature flags are usually permanent. |
| **[Feature deprecation](#feature-deprecation)** | Gradually phase out old features by disabling them for selected users while still keeping the code in place.  This is the inverse process of **gradual roll-outs**. The feature flag will be removed when the feature has been removed from the last set of users. |


## Recommendations for using feature flags

Each of the uses listed above comes with its own set of recommendations, as described below.


### Dark deployments

#### Pros

Dark deployments help facilitate CI/CD and [trunk-based development](/cloud-native-platform/new-component/feature-flags/trunk-based-development.html), which are key practices of high-performing software teams.  Teams that would ordinarily practise feature-based development can merge their code frequently, thereby reducing the impact of merge conflicts and helping to keep the main branch stable and deployable.

![Trunk based development with feature flags](/images/TBD_FeatureFlag.png)

#### Cons

Dark deployments discourage teams from breaking features down into their smallest releasable components, because there is no longer a need to do so in order to merge code back into `master` (since the code will never be executed by a user).  They also discourage regular and comprehensive testing before code is deployed to production, because the feature flag allows teams to deploy incomplete or broken features without releasing them to end-users.  This effectively defers the work of comprehensive testing and user feedback until the service is fully released to all users; hence any problems with the feature in real-world use will go undetected until very late in the day, where they could have a much more serious impact than if they had been found before the feature was fully complete.

Furthermore, dark deployments allow team members to work in isolation for longer, where they don't know what others are working on; code hidden behind a feature flag may or may not make the final cut for a release and hence cannot be relied upon.  This increases the likelihood of unintended duplication or redundancy between the work of two different developers who may have done the same thing in two different ways.  Finally, comprehensive automated testing is more complicated as all combinations of feature-flag values need to be included, which is easily overlooked while a feature is still under construction.

#### Recommendation

**Breaking features down into their smallest releasable components is *always* a good idea**; but it's hard and time-consuming and hence teams are disinclined to do it, particularly when they have an easier alternative courtesy of dark deployments.  Therefore:

- **Dark deployments should only be done by teams that are happy to practise trunk-based development**, whereby they will naturally break features down into small, releasable components and have a comprehensive and mature testing strategy in place before code reaches Production.

If you find them irresistible, then a golden rule should be:

- **Do not use dark deployments to hide features in Production that do not work**; instead, test fully in a lower environment before merging the (partially complete, fully working) code to `master`.

Finally:
    
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.
- **Changes to feature flags that influence the user experience in a live environment must be approved by the business owners beforehand**; this approval must be recorded by the feature-flag platform and be visible when required.


### Gradual roll-outs

#### Pros

Gradual roll-outs support safer releases when the team are releasing large, complex features all at once where there is a significant chance that something might not work for one or more sets of users.

#### Cons

Gradual roll-outs may encourage teams to release features in full before they are ready rather than releasing a steady stream of small, beneficial changes that are easy to test and roll back if necessary.  It also shifts the emphasis of user testing to a live environment where it may be better to focus more on testing in a lower environment to ensure that the feature is fit for purpose when it is released in Production.  Finally, there is a danger that the user segments chosen to test the feature early may not be representative of the wider user base, leading to a false sense of security that the feature is working well when it may not be.

#### Recommendation

As stated above, **breaking features down into their smallest releasable components is always the best option**.  Therefore:

- **Gradual roll-outs should only be done when some of the *users* are not ready for the new feature.**  In other words, gradual roll-outs should protect against incomplete or uncertain *business processes* rather than features that may contain bugs.

In some circumstances, it may be very difficult to break a large feature down into small, releasable units that add value; under these conditions, the business owners may feel more comfortable with a gradual roll-out.  If so, a golden rule should be:

- **Do not use raw IDs in the feature-flag platform for the purpose of segmenting users** as they could easily be mistyped and cannot be verified in the code.  Instead, use a descriptive name for the user segment that is easy to understand and verify in the code; in other words, the code should ultimately control the logic of who sees the feature, not the feature-flag platform.

Finally:
    
- **Feature flags should be removed as soon as the feature is fully released to all users.**  This should be enforced in the CI/CD pipeline.
- **Changes to feature flags that influence the user experience in a live environment must be approved by the business owners beforehand**; this approval must be recorded by the feature-flag platform and be visible when required.


### Feature experimentation / Beta testing

#### Pros

Beta testing can assist the development of a feature and provide timely feedback from users as to which aspects of the feature will actually prove to be useful in the real world.

#### Cons

As with gradual roll-outs, there is a danger that the users volunteering to test the feature may not be representative of overall user community, with selection bias likely to be significant.

#### Recommendation

**The use of feature flags to accomplish beta testing is acceptable** as there are few convenient alternatives.  As with gradual roll-outs, the features should always be working (albeit incomplete) before they are released to users, raw IDs should not be used in the feature-flag platform, feature flags should be removed once testing has been concluded, and business approval must be gained beforehand.


### A/B testing

#### Pros

This is a tried and tested method of improving an application by comparing the relative effectiveness of two (or more) variations of a completed feature and then retaining the best one.

#### Cons

None.  (There should be little danger of selection bias or lack of representation since the users are generally unaware that they are part of an A/B test and hence will not be biased towards one variation or the other, and they can be chosen at random.)

#### Recommendation

**The use of feature flags to accomplish A/B testing is acceptable.**  As with gradual roll-outs, the features should always be working before they are released to users, raw IDs should not be used in the feature-flag platform, feature flags should be removed once testing has been concluded, and business approval must be gained beforehand.


### User segmentation

#### Pros

A standard feature of many applications, this is the act of providing a customised experience for different users (or groups of users) according to their needs or preferences.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags**; although it may provide a convenient short-cut to achieving customisation, it is not the right tool for the job.  Instead, the code should be written to recognise the differences between groups of users and provide the appropriate experience for each user through polymorphism, inheritance and so on.  Preferences for individual users should be stored in configuration files or an application database.  Using a feature-flag platform for this purpose complicates the architecture and increases the cost unnecessarily: it creates a dependency on the feature-flag platform that is wholly unnecessary and lowers the capability of the code itself.


### User permissions

#### Pros

An essential feature of nearly all applications, this is the process of providing a regulated experience for different groups of users according to their privileges.

#### Cons

None.

#### Recommendation

**This should *not* be done using feature flags**; there are many better alternatives for implementing roles and permissions within an application, such as using a common IdAM component created specifically for this purpose.


### Operational toggles

#### Pros

The use of toggles to change the behaviour of certain features (or even disable them altogether) at runtime can help application administrators to prevent or limit the impact of high or unstable loads, unexpected responses from dependent services, lack of availability of essential resources and other unusual conditions or occurrences.

#### Cons

None.

#### Recommendation

**The use of feature flags to control or optimise the operation of the application during difficult periods is encouraged.**  However, a formal procedure for deciding when such changes are necessary, who should do them and how they should be recorded must be in place and reviewed on a regular basis.  Business approval must be gained before any changes are made.


### Monitoring and logging

#### Pros

The use of feature flags to dynamically alter the level of diagnostic information emitted by an application can help administrators to gain extra insights regarding the performance of the application when necessary (e.g., to explain unexpected behaviour).

#### Cons

None.

#### Recommendation

**The use of feature flags to increase or decrease diagnostic information according to need is encouraged.**  This both provides a means of capturing extra information when it is needed and reducing unnecessary log capture and storage during normal operation.  Care should be taken to ensure there is no adverse effect on application performance.


### Live debugging

#### Pros

In addition to capturing more diagnostic information, feature flags can be used to control the behaviour of the application in order to troubleshoot bugs in Production that cannot be reproduced in lower environments.  For example, a particular user process exhibiting a bug could be dynamically modified to alter or even miss certain steps in order to isolate the problem and identify the cause.

#### Cons

Making experimental changes to a live application is always dangerous due to the possibility of causing other problems for logged-in customers from unintended side-effects of the developers' actions.  Furthermore, these have the potential to distort the regular usage metrics relied upon by business teams monitoring the performance and effectiveness of the application.

#### Recommendation

**The use of feature flags to enable live debugging is acceptable *only as a last resort*, and great care must be taken.**  The developers carrying out the live debugging should be the most senior developers available in order to minimise the possibility of mistakes.  Approval *by the service owner* must be gained before any changes are made.


### Short-cuts in testing

#### Pros

Feature flags can be used in a test environment to speed up the testing process; for example, by-passing the need to authenticate through the use of a special privileged user account, or assigning stock data and properties to a test user.

#### Cons

There is a danger that these short-cuts will be forgotten and left in place, and potentially exploited.  It is also more difficult to record exactly what testing took place when the tests are influenced by feature flags controlled in a separate piece of software.

#### Recommendation

**Feature flags should *not* be used for taking short-cuts in testing.**  Instead of simplifying an integration test (for example, by removing the need to authenticate), it is better to create smaller service- or contract-level tests lower down the [test pyramid](/standards/principles/test.html#types-of-testing) that verify the individual components of the code in isolation and have fewer but nonetheless complete integration tests for the end-to-end user journey.  Traditional methods of creating test data are always available and are likely to be better suited to the task (e.g., creating entities in a test database rather than injecting them from the feature-flag platform).


### Feature deprecation

#### Pros

Feature flags can be used to enable the gradual removal (or "gradual roll-in") of features on a per-user (or per-group) basis, to ensure that all users are prepared for the withdrawal of the feature in question.

#### Cons

None.

#### Recommendation

**The use of feature flags for gradual feature deprecation is acceptable.**  As with gradual roll-outs, raw IDs should not be used in the feature-flag platform, feature flags should be removed once the feature has been removed for all users, and business approval must be gained beforehand.


[GOT TO HERE]<br />
[GOT TO HERE]<br />
[GOT TO HERE]<br />
[GOT TO HERE]<br />
[GOT TO HERE]<br />
[GOT TO HERE]<br />
[GOT TO HERE]<br />

## Feature-flag platforms at HMCTS

The following feature-flag platforms are currently in use at HMCTS:

### [LaunchDarkly](https://launchdarkly.com/)

A commercial feature-flag platform that provides a user interface for managing feature flags, as well as SDKs for various programming languages.  It is the recommended feature-flag platform for HMCTS projects.

### [Azure App Configuration](https://learn.microsoft.com/en-us/azure/azure-app-configuration/)

A Microsoft Azure service that provides a centralised configuration store for applications, including feature flags.  It is suitable for projects that are already using Azure services and want to keep their feature flags within the Azure ecosystem.

### Environment variables

A simple way to manage feature flags by storing them as environment variables in the application's runtime environment.  This is suitable for small projects or projects that do not require a full-featured feature-flag platform.


End to end Process:

1. Developer creates and commits short lived feature branch with Feature flag off.
2. Implements feature through iterations of small feature lifecycle.
3. Code is continuously released.
4. Retire feature toggle.


### Accessing LaunchDarkly

Developers automatically get access by being part of 'DTS CFT Developers' or 'DTS SDS Developers', non-developers can get access with the 'DTS LaunchDarkly' group.
see [onboarding](../onboarding/person/index.html) process to request access. You will need to login from [myapps.microsoft.com](https://myapps.microsoft.com/hmcts.net).

After you've logged in once you will be able to login from [app.launchdarkly.com](https://app.launchdarkly.com/).

### Documentation

Documentation can be accessed directly from the [LaunchDarkly](https://docs.launchdarkly.com/home) website.
Their [blog](https://launchdarkly.com/blog/) contains good information.

### Creating a new project

See [hmcts/launchdarkly-terraform](https://github.com/hmcts/launchdarkly-terraform) for instructions on how to setup your new project.

### Environments

We currently provide 'Test' and 'Production' environments by default within Launch Darkly. Flags are generally set to the same value in both 'Production' and the 'Test' environment, [flag targeting](https://docs.launchdarkly.com/guides/tutorials/rules-and-targeting) is used to control rollout of flags to users across environments.

If your team does require additional environments, you can do this by updating your teams [terraform.tfvars](https://github.com/hmcts/launchdarkly-terraform/blob/896019ed1efdebdf9237b7811ab2b9585a7708f2/terraform.tfvars#L59-L61). 
It is not recommended to do this as targeting rules should be simpler to manage and ensure consistency across environments.

